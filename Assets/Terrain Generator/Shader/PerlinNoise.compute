// PerlinNoise.compute
// Multi-octave 2D Perlin noise generator
//
// Overview
// - Each thread computes one height sample at integer (x,y) in a resolution x resolution grid
// - We iterate over multiple octaves, increasing frequency (_Lacunarity) and reducing amplitude (_Persistence)
// - Results are written into a 1D RWStructuredBuffer<float> with row-major layout: index = x + y * _Resolution
// - CPU provides offsets and parameters to match CPU implementation for deterministic output per seed

#pragma kernel CSMain

RWStructuredBuffer<float> Heights;

// Parameters set from C# to mirror the CPU loop
int _Resolution;  // width/height of the square heightmap
int _Octaves;     // number of layers
float _Lacunarity; // frequency multiplier per octave
float _Persistence; // amplitude multiplier per octave
float _Scale;     // base frequency scale
float _Amplitude; // base amplitude for first octave
float _OffsetX;   // random offset X for de-tiling
float _OffsetY;   // random offset Y for de-tiling

// Simple integer hash to pseudo-randomize gradients
uint Hash(uint x)
{
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

// Perlin's fade function for smooth interpolation
float2 Fade2(float2 t)
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// 2D gradient selection based on hashed corner index
float Grad2(uint h, float2 p)
{
    // 8 gradient directions
    switch (h & 7u)
    {
        case 0u: return  p.x + p.y;
        case 1u: return  p.x - p.y;
        case 2u: return -p.x + p.y;
        case 3u: return -p.x - p.y;
        case 4u: return  p.x;
        case 5u: return -p.x;
        case 6u: return  p.y;
        default: return -p.y;
    }
}

// Single-octave 2D Perlin noise in [0,1]
float Perlin2(float2 p)
{
    float2 pi = floor(p);
    float2 pf = p - pi;

    uint xi = (uint)pi.x;
    uint yi = (uint)pi.y;

    uint h00 = Hash(Hash(xi) ^ yi);
    uint h10 = Hash(Hash(xi + 1u) ^ yi);
    uint h01 = Hash(Hash(xi) ^ (yi + 1u));
    uint h11 = Hash(Hash(xi + 1u) ^ (yi + 1u));

    float n00 = Grad2(h00, pf + float2(0.0, 0.0));
    float n10 = Grad2(h10, pf + float2(-1.0, 0.0));
    float n01 = Grad2(h01, pf + float2(0.0, -1.0));
    float n11 = Grad2(h11, pf + float2(-1.0, -1.0));

    float2 u = Fade2(pf);

    float nx0 = lerp(n00, n10, u.x);
    float nx1 = lerp(n01, n11, u.x);
    float nxy = lerp(nx0, nx1, u.y);

    // Normalize to [0,1]
    return 0.5 * (nxy * 0.70710678 + 1.0);
}

// Thread group size; tune based on target hardware. 8x8 is broadly safe.
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Resolution || id.y >= (uint)_Resolution) return;
    int index = id.x + id.y * _Resolution;

    float freq = max(_Scale, 0.0001);
    float amp = _Amplitude;
    float height = 0.0;

    // Match CPU: normalize indices by resolution and apply scale/offset on top
    float2 baseUV = (float2(id.x, id.y) / max(1, _Resolution));
    float2 offset = float2(_OffsetX, _OffsetY);

    [loop]
    for (int o = 0; o < max(1, _Octaves); o++)
    {
        float2 sample = baseUV * freq + offset;
        float n = Perlin2(sample);
        height += n * amp;
        freq *= _Lacunarity;
        amp *= _Persistence;
    }

    Heights[index] = height;
}
